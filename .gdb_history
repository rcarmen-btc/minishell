Стратегия вашей оболочки заключается в том, чтобы родительский процесс выполнял все конвейерные операции и перенаправление, прежде чем разветвлять процессы. Таким образом, дети унаследуют перенаправление. Родителю необходимо сохранить ввод/вывод и восстановить его в конце. Stderr одинаков для всех процессов.

На этом рисунке процесс a отправляет вывод в канал 1. Затем b считывает свои входные данные из канала 1 и отправляет свои выходные данные в канал 2 и так далее. Последняя команда d считывает входные данные из канала 3 и отправляет выходные данные в outfile. Входные данные от a поступают из файла. В следующем коде показано, как реализовать это перенаправление. Для простоты была устранена некоторая проверка ошибок.

Метод execute() является основой оболочки. Он выполняет простые команды в отдельном процессе для каждой команды и выполняет перенаправление.
Строки 3 и 4 сохраняют текущие stdin и stdout в двух новых файловых дескрипторах с помощью функции dup (). Это позволит в конце выполнения() восстановить stdin и stdout так, как это было в начале выполнения(). Причина этого в том, что stdin и stdout (файловые дескрипторы 0 и 1) будут изменены в родительском файле во время выполнения простых команд

Строки с 6 по 14 проверяют, есть ли файл перенаправления ввода в таблице команд формы “команда < файл ввода”. Если есть перенаправление ввода, то он откроет файл в файле и сохранит его в fdin. В противном случае, если перенаправление ввода отсутствует, он создаст файловый дескриптор, ссылающийся на ввод по умолчанию. В конце этого блока инструкций fdin будет файловым дескриптором, который вводится из командной строки и который можно закрыть, не затрагивая программу родительской оболочки.

Строка 18-это цикл for, который повторяет все простые команды в таблице команд. Этот цикл for создаст процесс для каждой простой команды и выполнит соединения трубопроводов.
Строка 20 перенаправляет стандартный ввод, поступающий из fdin. После этого любое чтение из stdin будет происходить из файла, указанного fdin. На первой итерации ввод первой простой команды будет исходить от fdin. fdin будет переназначен входному каналу позже в цикле. Строка 21 закроет fdin, так как дескриптор файла больше не понадобится. В целом рекомендуется закрывать файловые дескрипторы до тех пор, пока они не понадобятся, поскольку для каждого процесса доступно всего несколько (обычно 256 по умолчанию).

Строка 23 проверяет, соответствует ли эта итерация последней простой команде. Если это так, он проверит в строке 25, есть ли перенаправление выходного файла формы “команда > outfile”, откроет outfile и назначит его fdout. В противном случае в строке 30 будет создан новый файловый дескриптор, указывающий на ввод по умолчанию. Строки с 23 по 32 гарантируют, что fdout является файловым дескриптором для вывода на последней итерации.

Строки с 34 по 42 выполняются для простых команд, которые не являются последними. Для этих простых команд выводом будет канал, а не файл. Линии 38 и 39 создают новую трубу. Новая труба. Канал-это пара файловых дескрипторов, передаваемых через буфер. Все, что записано в файловом дескрипторе fdpipe[1], может быть прочитано из fdpipe[0]. В строках 41 и 42 fdpipe[1] присваивается fdout, а fdpipe[0] присваивается fdin

Строка 41 fdin=fdpipe[0] может быть ядром реализации каналов, поскольку она делает ввод fdin следующей простой команды на следующей итерации исходящим из fdpipe[0] текущей простой команды

Строки 45 перенаправляют stdout для перехода к файловому объекту, на который указывает fdout. После этой строки stdin и stdout были перенаправлены либо в файл, либо в канал. Строка 46 закрывает вывод, который больше не нужен.

Когда программа оболочки находится в строке 48, перенаправления ввода и вывода для текущей простой команды уже установлены. Строка 49 разветвляет новый дочерний процесс, который унаследует файловые дескрипторы 0,1 и 2, соответствующие stdin, stdout и stderr, которые перенаправляются на терминал, файл или канал. Если при создании процесса нет ошибки, в строке 51 вызывается системный вызов execvp (), который загружает исполняемый файл для этой простой команды. Если execvp завершится успешно, он не вернется. Это связано с тем, что в текущем процессе был загружен новый исполняемый образ и память была перезаписана, поэтому возвращаться не к чему

Строка 55-это конец цикла for, который повторяет все простые команды.
После выполнения цикла for все простые команды выполняются в своем собственном процессе и обмениваются данными с помощью каналов. Поскольку stdin и stdout родительского процесса были изменены во время перенаправления, строки 58 и 59 вызывают dup2 для восстановления stdin и stdout в тот же файловый объект, который был сохранен в tmpin и tmpout. В противном случае оболочка получит входные данные из последнего файла, на который были перенаправлены входные данные. Наконец, строки 60 и 61 закрывают временные файловые дескрипторы, которые использовались для сохранения stdin и stdout процесса родительской оболочки.

Если в командной строке не был установлен фоновый символ“&”, это означает, что родительский процесс оболочки должен дождаться завершения последнего дочернего процесса в команде, прежде чем печатать приглашение оболочки. Если был установлен фоновый символ“&”, это означает, что командная строка будет выполняться асинхронно с оболочкой, поэтому процесс родительской оболочки не будет ждать завершения команды и немедленно выведет приглашение. После этого выполняется выполнение команды.

В приведенном выше примере не выполняется перенаправление стандартной ошибки( файловый дескриптор 2). Семантика этой оболочки должна заключаться в том, что все простые команды будут отправлять stderr в одно и то же место. Приведенный выше пример может быть изменен для поддержки перенаправления stderr В приведенном выше примере не выполняется перенаправление стандартной ошибки( файловый дескриптор 2). Семантика этой оболочки должна заключаться в том, что все простые команды будут отправлять stderr в одно и то же место. Приведенный выше пример может быть изменен для поддержки перенаправления stderrstart
n
s
n
s
n
q
start
n
s
n
n
n
n
n
s
n
n
n
n
n
start
n
start
n
s
n
n
n
s
n
s
n

start
n
start
n
s
n
s
n
n
n
s
q
start
n
s
n
s
n
s
n
print cmdlst
printf "%s\n" cmdlst->value
printf "%s\n", cmdlst->value
printf "%s\n", cmdlst->cmdline
printf "%s\n", token->value
printf "%s\n", cmdlst->cmdline[0]
n
printf "%s\n", cmdlst->cmdline[0]
printf "%s\n", cmdlst->cmdline[1]
start
n
s
n
s
n
s
n
printf "%s\n", cmdlst->cmdline[1]
printf "%s\n", cmdlst->cmdline[0]
printf "%s\n", cmdlst->cmdline[0]
n
printf "%s\n", cmdlst->cmdline[0]
start
n
s
n
s
n
n
n
s
n
printf "%s\n", cmdlst->cmdline[0]
n
print cmd_i
n
printf "%s\n", cmdlst->cmdline[1]
printf "%s\n", cmdlst->cmdline[0]
start
n
n
s
n
b
start
n
s
n
n
n
start
n
n
s
n
s
n
start
n
n
s
n
n
s
n
start
n
n
n
s
n
s
n
n
printf "%s\n", cmdlst->cmdline[1]
printf "%s\n", cmdlst->cmdline[2]
printf "%s\n", cmdlst->cmdline[0]
printf "%s\n", cmdlst->cmdline[2]
printf "%s\n", cmdlst->cmdline[0]
printf "%s\n", cmdlst->cmdline[1]
printf "%s\n", cmdlst->type
printf "%d\n", cmdlst->type
printf "%s\n", cmdlst->cmdline[1]
printf "%s\n", token->value
n
p
n
n
n
n
n
n
n
printf "%s\n", token->value
a b | c
start
n
n
s
n
n
n
printf "%s\n", token->value
c
n
n
printf "%s\n", token->value
n
printf "%s\n", token->value
n]
n
start
n
n
n
